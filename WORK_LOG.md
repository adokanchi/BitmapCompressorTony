Name: Tony Dokanchi

| Date        |     Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Update |
|:------------|:-------------:|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| April 5     |    9-10pm     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 I tried to write abstract, efficient code. |
| November 21 |  10-10:30pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     I coded my intial approach, where each string of 1s or 0s is represented by a byte where the first bit is what character is being represented and the last 7 bits are the number of repeats (e.g. 10010111 would represent 23 ones). I'm having an issue where my compression algorithm, when operating on q32x48.bin, is outputting 0111111101000001, which represents 192 zeros. I have no clue why. |
| November 21 |  12-12:30pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            I spent a lot of time debugging, eventually coming to the fact that it wasn't an issue with the compression algorithm itself. The string I read in was just 192 zeros. I figured out that this is when reading to a string, BinaryStdIn.readString() converts every 8 bits to a char using UTF-8. My comparison involved comparing each character of the read string to the character '1', but instead of comparing each individual bit, it compared a sequence of 8 bits encoded as a character. q32x48 has 32*48=1536 bits, giving 192 characters when encoded using UTF-8, and none of the sequences of 8 bits happened to exactly match the ASCII value for '1', so all comparisons failed and I got a string of 192 zeros. |
| November 21 |   3-3:30pm    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         To fix the above bug, instead of reading in the whole string using BinaryStdIn.readString() and doing analysis on that string, I used BinaryStdIn.readBoolean() whenever I wanted to process another bit. This involved recoding most of the code. Coding expand() was relatively simple, as I knew that in every byte, I just had to take the first bit and repeat it a number of times equal to the int stored in the last 7 bits, which is pretty much just a for loop in a while loop. The algorithm seems to work for all three provided .bin files; q32x48.bin is compressed with a ratio of 74.48%, q64x96 is compressed with a ratio of 37.5%, and mystery.bin is compressed with a ratio of 15.7%. I'm not below 30% on two of the test cases, but I'm getting there, and I still have some ideas of how to deal with "adversarial" data. |
| December 2  | 11:15-11:45pm |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             I've discovered a new issue where, if I encounter a run of more than 255 of a single bit type, then the 256th bit will be flipped (and the 512th, 768th, etc). I haven't found a solution yet. |
| December 3  |  9:15-9:45pm  | The solution was to just recode everything. The old method was using complicated workarounds for simple problems. I did everything in a complicated way because I was struggling to simultaneously be able to handle the cases where I have a run of exactly 255 bits and where I have a run of more than 255 bits. The solution, quite simply, was just to act like the run stopped at 255 and swap the target I'm looking for. If the run ends at 255, the algorithm carries on normally. If it doesn't end at 255, the algorithm sees that the bits we're reading in are different from the target variable, which makes it act like we ended a run, printing out the number of bits counted (which is 0) and swapping the target back to what it originally was. I couldn't do this before because the process of reading in a bit before we're in a state of being allowed to process that bit confused me---it takes some mental gymnastics to get used to, but I think I'm getting comfortable with it. I'm not absolutely certain my code is able to handle every possible test case, but it seems promising. I have a 15.5% compression ratio for mystery.bin, a 37.4% ratio for q64x96.bin, and a 74.5% ratio for q32x48.bin. The ratio of the algorithm obviously depends a lot on the size of the runs, but it seems that for larger bitmaps, where we expect larger runs, it performs at least decently well. I didn't have time to implement some of the more creative ideas I had for optimization (like having two modes where I can choose to not encrypt certain adversarial data), but they don't seem to be necessary. |
.

To add a new row to the table, click into a cell and then hit shift-enter.