Name: Tony Dokanchi

| Date        |    Time    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Update |
|:------------|:----------:|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| April 5     |   9-10pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         I tried to write abstract, efficient code. |
| November 21 | 10-10:30pm |                                                                                                                                                                                                                                                                                                                                                                                                                                             I coded my intial approach, where each string of 1s or 0s is represented by a byte where the first bit is what character is being represented and the last 7 bits are the number of repeats (e.g. 10010111 would represent 23 ones). I'm having an issue where my compression algorithm, when operating on q32x48.bin, is outputting 0111111101000001, which represents 192 zeros. I have no clue why. |
| November 21 | 12-12:30pm |                                                                                                                    I spent a lot of time debugging, eventually coming to the fact that it wasn't an issue with the compression algorithm itself. The string I read in was just 192 zeros. I figured out that this is when reading to a string, BinaryStdIn.readString() converts every 8 bits to a char using UTF-8. My comparison involved comparing each character of the read string to the character '1', but instead of comparing each individual bit, it compared a sequence of 8 bits encoded as a character. q32x48 has 32*48=1536 bits, giving 192 characters when encoded using UTF-8, and none of the sequences of 8 bits happened to exactly match the ASCII value for '1', so all comparisons failed and I got a string of 192 zeros. |
| November 21 |  3-3:30pm  | To fix the above bug, instead of reading in the whole string using BinaryStdIn.readString() and doing analysis on that string, I used BinaryStdIn.readBoolean() whenever I wanted to process another bit. This involved recoding most of the code. Coding expand() was relatively simple, as I knew that in every byte, I just had to take the first bit and repeat it a number of times equal to the int stored in the last 7 bits, which is pretty much just a for loop in a while loop. The algorithm seems to work for all three provided .bin files; q32x48.bin is compressed with a ratio of 74.48%, q64x96 is compressed with a ratio of 37.5%, and mystery.bin is compressed with a ratio of 15.7%. I'm not below 30% on two of the test cases, but I'm getting there, and I still have some ideas of how to deal with "adversarial" data. |


To add a new row to the table, click into a cell and then hit shift-enter.